---
---
---

### JUnit 5 - это фреймворк для автоматизированного тестирования приложений на языке Java.
Он позволяет проводить модульные тесты, проверяя отдельные части кода программы. Это дополнение к ручному тестированию, которое может помочь автоматизировать такие задачи, как установка продукта, создание тестовых данных, взаимодействие с графическим интерфейсом пользователя и определение проблем. Однако автоматические тесты не могут полностью заменить ручное тестирование, поэтому они используются преимущественно для регрессионного тестирования. ***JUnit 5*** является частью семейства фреймворков ***xUnit***, которые основаны на структуре и функциональности ***SUnit***, созданного для языка программирования ***Smalltalk***. Название фреймворков этого семейства образуется путем замены первой буквы "S" на первую букву названия языка программирования, например, "JUnit" для Java. 

### Как  подключить

---

Для подключения JUnit 5 к проекту необходимо добавить в раздел ***dependcies*** файла ***build.gradle*** зависимость:
```java
dependencies {
    testImplementation (
            "org.junit.jupiter:junit-jupiter:5.8.2")
}

test {
    useJUnitPlatform()
}
```

Для ***Maven*** надо добавить зависимость в файл ***pom.xml***

```java
<dependency>  
    <groupId>org.junit.jupiter</groupId>  
    <artifactId>junit-jupiter-api</artifactId>  
    <version>LATEST</version>  
    <scope>test</scope>  
</dependency>
```

### Аннотации

---

	 Аннотации JUnit 5 пока можно считать своеобразными метками, указывающим, что конкретный метод/класс надо выполнить по-особенному. Аннотация `@Test` необходима для отметки метода/класса в качестве теста JUnit.

#### @Test - указывает, что данный метод является тестом. При запуске тестов, это является тригером для запуска кода

```java
@Test
void assertTets() {
    Assertions.assertTrue(2 < 3);
}
```

#### @BeforeEach и @AfterEach - этими аннотациями отмечаются классы, которые должны выполниться ДО или ПОСЛЕ #каждого теста

```java
@BeforeEach
void openPage() {
    Selenide.open("https://page.com");
}

@AfterEach
void closeWindow() {
    WebDriverRunner.closeWindow();
}
```

#### @BeforeAll и @AfterAll - здесь смысл тот же, только выполняться эти методы будут один раз ДО всех тестов и ПОСЛЕ #всех тестов соответственно

```java
@BeforeAll
static void initDB() {
    //...
    //...
}

@AfterAll
static void cleanDB() {
    //...
    //...
}
```

#### @Tag - с помощью этой аннотации можно отмечать тесты ключевым словом и таким образом собирать наборы тестов. Благодаря этому можно будет запустить не все тесты, а например только с тегом ***"sum"***

```java
@Tag("summ")  
void testForSumm(int firstTerm, int secondTerm, int expected) {  
    Calc calcSumm = new Calc();  
    int ressultSum = calcSumm.summation(firstTerm, secondTerm);  
    Assertions.assertEquals(expected, ressultSum, "Не работает");  
}
```

#### @DisplayName - позволяет текстом описать суть проверки. Дальше эта информация будет отображаться в результатах прохождения тестов и в шагах отчета о прохождении тестов

```java
@DisplayName("Проверка работы вычитания калькулятора")  
void testForSubtraction(int firstTerm, int secondTerm, int expected) {  
    Calc calcSub = new Calc();  
    int ressultSub = calcSub.subtraction(firstTerm, secondTerm);  
    Assertions.assertEquals(expected, ressultSub, "Не работает");  
}
```

#### @Disabled - если какой-то тест падает из-за ошибки со стороны разработчиков или его просто пока надо отключить, то не следует комментировать все тело теста. Для этих целей предусмотрена аннотации `@Disabled`. Стоит ставить ее перед тем тестом, который необходимо отключить. Можно скрыть не только один тест, но и все тесты в классе. Для этого аннотации надо указать перед классом.

```java
@Disabled("Ужас! Все падает!")
@DisplayName("Тест главной страницы")
@Test
void mainPageTets() {
    // Тело теста
}
```

---

#### Что такое тест тест-кейс

Тест-кейс — это профессиональная документация тестировщика, последовательность действий направленная на проверку какого-либо функционала, описывающая как прийти к фактическому результату. Набор тест-кейсов называют тест-комплектом.

**Что должно быть в тест-кейсе:**

- Уникальный номер — помогает в больших проект организовано содержать базу тест-кейсов;
- Заголовок — описывает основную идея теста;
- Предусловия — описывает условия, которые не имеют прямого отношения к тест-кейсу, но все равно должны быть выполнены;
- Шаги — последовательность действий теста;
- Ожидаемый результат — результат, то, что мы ожидаем увидеть после выполнения теста.

**Чего не должно быть в тест-кейсах:**

- Расплывчатых формулировок шагов;
- Излишних деталей (не надо описывать каждый микрошаг);
- Зависимостей от других тест-кейсов.
Во время тестирования бывает так, что код надо проверить несколько раз, но с разными входными данными. В JUnit5 есть механизм, позволяющий отделить код теста от данных теста и запускать тест несколько раз.

---


**@ParameterizedTest** Чтобы выполнить тест несколько раз, но с разными аргументами, следует использовать аннотацию `@ParameterizedTest`. При этом нам нужен поставщик данных для теста. Для этого можно использовать аннотацию `@ValueSource()`.

```java
@ValueSource(strings = {
    "Google",
    "Yandex"
})
@ParameterizedTest
void SearchTest (String testData) {
    // тело теста
}
```

Помимо менеджмента тестов, JUnit нам предоставляет возможность проводить проверки, которые за частую делаются разработчиками при проверке логики работы какого то метода или куска кода. Называется эта прелесть ***Assertions***.

Как работают эти Assertы? А просто. Они берут ожидаемый результат, который мы хотим увидеть и фактический результат, который выдает программа и сравниваем их. Если результат работы программы совпадает с ожидаемым результатом, то проверка проходит успешно!

Вот примеры некоторых таких проверок:

```java
Assertions.assertEquals("Good", "Good");
//Ожидали Good и получили Good, поэтому тест пройдет
Assertions.assertEquals("Good", "Bad");
// Ожидали Good, а получили Bad. Тест упал.
Assertions.assertTrue(5 > 2);
// 5 на самом деле больше 2 и тест пройдет
//Если утверждение в скобках верно, то тест пройдет
Assertions.assertFalse(10 < 2);
// 10 не меньше 2, значит тест тоже пройдет
Assertions.assertAll(
   () -> Assertions.assertFalse(10 < 2),
   () -> Assertions.assertTrue(5 > 2),
   () -> Assertions.assertEquals("Good", "Good")
);//Позволяет проверить сразу несколько утверждений. Даже если одно из них упадет, то все равно будут выполнены все до самого конца, а система покажет те, которые упали
```
---

